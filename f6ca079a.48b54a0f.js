(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{151:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var o=t(1),r=t(6),a=(t(0),t(156)),i=t(158),l={id:"lesson9",title:"The Mounting Process",sidebar_label:"Lesson9"},c={id:"advanceComp/lesson9",title:"The Mounting Process",description:"import useBaseUrl from '@docusaurus/useBaseUrl';\r",source:"@site/docs\\advanceComp\\lesson9.md",permalink:"/github-pages-test/docs/advanceComp/lesson9",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/advanceComp/lesson9.md",sidebar_label:"Lesson9",sidebar:"someSidebar",previous:{title:"Evan You on Functional Components",permalink:"/github-pages-test/docs/advanceComp/lesson8"},next:{title:"Evan You on the Mounting Process",permalink:"/github-pages-test/docs/advanceComp/lesson10"}},s=[{value:"What are this _render() &amp; _update() functions doing?",id:"what-are-this-_render--_update-functions-doing",children:[]}],u={rightToc:s};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"In previous lessons we looked at the Vue internals for reactivity and rendering, but we didn\u2019t talk about the mounting process. Learning more about how this works will help improve our understanding of the Vue internals and improve our debugging skills."),Object(a.b)("p",null,"Remember the ",Object(a.b)("inlineCode",{parentName:"p"},"mountComponent")," function?"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"export function mountComponent (...) {\n...\ncallHook(vm, 'beforeMount') // <-- Lifecycle hook\n\nlet updateComponent = () => {\n  vm._update(vm._render(), hydrating)  // <-- This is our target method\n}  \nnew Watcher(vm, updateComponent, noop, null, true) // <-- Our watcher, which runs our target method, and reruns it when needed\n...\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"_render")," calls our component render function which returns a Virtual Node (VNode), and _update knows how to take that VNode and make updates to the actual DOM."),Object(a.b)("img",{alt:"",src:Object(i.a)("/img/mounting1.png")}),Object(a.b)("p",null,"But that doesn\u2019t answer the following questions:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Where is ",Object(a.b)("inlineCode",{parentName:"li"},"mountComponent")," actually called?"),Object(a.b)("li",{parentName:"ul"},"Where does a template get compiled into a render function?"),Object(a.b)("li",{parentName:"ul"},"What does ",Object(a.b)("inlineCode",{parentName:"li"},"_render")," do?"),Object(a.b)("li",{parentName:"ul"},"What does ",Object(a.b)("inlineCode",{parentName:"li"},"_update")," do?")),Object(a.b)("p",null,"In this lesson we will do our best to answer these questions starting with the first, by looking for ",Object(a.b)("inlineCode",{parentName:"p"},"mountComponent"),".\nOur search starts back in our ",Object(a.b)("inlineCode",{parentName:"p"},"_init")," method that should look familiar by now:"),Object(a.b)("p",null,"/src/core/instance/index.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"export function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    ...\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n    \n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)  // <-- Where the template is compiled (if needed), and mountComponent must be eventually.\n    }\n  }\n}\n")),Object(a.b)("p",null,"The definition of ",Object(a.b)("inlineCode",{parentName:"p"},"$mount")," is determined by the kind of Vue build we\u2019re running, and if we look inside ",Object(a.b)("inlineCode",{parentName:"p"},"/scripts/config.js")," inside the Vue source we\u2019ll see a bunch of builds, including the following two:"),Object(a.b)("p",null,"/scripts/config.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),'const builds = {\n  // runtime-only build (Browser)\n  "web-runtime-dev": {\n    entry: resolve("web/entry-runtime.js"), // This mount only includes the code to run render functions.\n    dest: resolve("dist/vue.runtime.js"),\n    ...\n  },\n  // Runtime+compiler development build (Browser)\n  "web-full-dev": {\n    entry: resolve("web/entry-runtime-with-compiler.js"), // includes code to compile templates into render functions and run them\n    dest: resolve("dist/vue.js"),\n    ...\n  }\n};\n')),Object(a.b)("p",null,"The definition of ",Object(a.b)("inlineCode",{parentName:"p"},"$mount")," we\u2019re calling in this walkthrough can be found inside ",Object(a.b)("inlineCode",{parentName:"p"},"entry-runtime-with-compiler.js")," and is listed below. We want both the runtime and the compiler, because in our example we\u2019ll be both compiling our templates into render functions and rendering them. Remember, if we\u2019re pre-compiling our templates then our user\u2019s browser doesn\u2019t need to know how to compile, and our ",Object(a.b)("inlineCode",{parentName:"p"},"$mount")," would be different."),Object(a.b)("p",null,"/src/platforms/web/entry-runtime-with-compiler.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"const mount = Vue.prototype.$mount // This version of mount is defined inside runtime/index.js\nVue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component {\n  el = el && query(el)\n  const options = this.$options\n  \n  // Only compile a template if we don't already have a render function\n  if (!options.render) {\n    let template = options.template\n    if (template) {  // do compilation in here!\n      const { render, staticRenderFns } = compileToFunctions(template, { ...  }, this)\n      options.render = render  // Now we have compiled .. see below\n    }\n  }\n  // Call previously defined mount before returning\n  return mount.call(this, el, hydrating)\n}\n")),Object(a.b)("p",null,"It\u2019s our ",Object(a.b)("inlineCode",{parentName:"p"},"compileToFunctions")," call that converts our component template that looks like this:"),Object(a.b)("p",null,"template: ",Object(a.b)("inlineCode",{parentName:"p"},"<h1>{{ this.name }}</h1>"),"\nInto something that looks more like:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"{\n  with(this){return _c('h1',[_v(_s(this.name))])}\n}\n")),Object(a.b)("p",null,"As you see above, this becomes the value of options.render, or more specifically ",Object(a.b)("inlineCode",{parentName:"p"},"this.$options.render"),". If our component has a render function, this step just gets skipped."),Object(a.b)("p",null,"You might be wondering what the underscore methods are ",Object(a.b)("inlineCode",{parentName:"p"},"(_c, _v, and _s)"),". Inside ",Object(a.b)("inlineCode",{parentName:"p"},"initRender")," we find this for ",Object(a.b)("inlineCode",{parentName:"p"},"_c"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n")),Object(a.b)("p",null,"It calls our createElement function with the proper context. For the others if we look inside:"),Object(a.b)("p",null,"/src/core/instance/render-helpers.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"target._o = markOnce\ntarget._n = toNumber\ntarget._s = toString // <-------\ntarget._l = renderList\ntarget._t = renderSlot\ntarget._q = looseEqual\ntarget._i = looseIndexOf\ntarget._m = renderStatic\ntarget._f = resolveFilter\ntarget._k = checkKeyCodes\ntarget._b = bindObjectProps\ntarget._v = createTextVNode // <------\ntarget._e = createEmptyVNode\ntarget._u = resolveScopedSlots\ntarget._g = bindObjectListeners\n")),Object(a.b)("p",null,"If we were to extrapolate our render function we\u2019d have:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"{\n  with(this){return createElement('h1',[ createTextVNode ( toString(this.name))])}\n}\n")),Object(a.b)("p",null,"Once we compile our render function and get to the bottom of our ",Object(a.b)("inlineCode",{parentName:"p"},"$mount")," call we find ",Object(a.b)("inlineCode",{parentName:"p"},"mount.call(this, el, hydrating)"),". This calls our previously defined ",Object(a.b)("inlineCode",{parentName:"p"},"$mount"),":"),Object(a.b)("p",null,"/src/platforms/web/runtime.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"// public mount method\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined // Get or create the DOM element if we haven't yet\n  return mountComponent(this, el, hydrating) // <-- Here's our mountComponent call!\n}\n")),Object(a.b)("p",null,"We found it, we found the ",Object(a.b)("inlineCode",{parentName:"p"},"mountComponent")," call which leads us back to lifecycle.js:"),Object(a.b)("p",null,"/src/core/instance/lifecycle.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"export function mountComponent (\n    vm: Component,\n    el: ?Element,\n    hydrating?: boolean\n): Component {\n    vm.$el = el\n    ...\n    callHook(vm, 'beforeMount') \n    \n    let updateComponent\n    updateComponent = () => {\n    vm._update(vm._render(), hydrating)\n    }\n\n    new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)\n    \n    hydrating = false\n    return vm\n}\n")),Object(a.b)("p",null,"Remember the watcher from this diagram?"),Object(a.b)("img",{alt:"mounting2",src:Object(i.a)("/img/mounting2.png")}),Object(a.b)("p",null,"We send our ",Object(a.b)("inlineCode",{parentName:"p"},"updateComponent")," function into the watcher, and it takes care of invoking it for the first time. When it gets invoked you can see it first calls  ",Object(a.b)("inlineCode",{parentName:"p"},"_render")," which returns the VNode (like in the diagram) and then calls ",Object(a.b)("inlineCode",{parentName:"p"},"_update")," which updates the actual DOM. This leads to our final two questions:"),Object(a.b)("h2",{id:"what-are-this-_render--_update-functions-doing"},"What are this _render() & _update() functions doing?"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"_render")," function can be found inside instance/render.js:"),Object(a.b)("p",null,"/src/core/instance/render.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    const { render, _parentVnode } = vm.$options\n    \n    // set parent vnode. this allows render functions to have access\n        // to the data on the placeholder node.\n    vm.$vnode = _parentVnode\n    // render self\n    let vnode\n    try {\n        vnode = render.call(vm._renderProxy, vm.$createElement) // <--- Executes our render function, returning a VNode\n    } catch (e) { ... }\n\n    // set parent    \n    vnode.parent = _parentVnode\n    return vnode\n}\n")),Object(a.b)("p",null,"See where our render function is called? This runs this render function which we compiled earlier:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"(function() {\n  with(this){return _c('h1',[_v(_s(this.name))])}\n})\n")),Object(a.b)("p",null,"Since ",Object(a.b)("inlineCode",{parentName:"p"},"this.name")," is reactive, this is where our ",Object(a.b)("inlineCode",{parentName:"p"},"getter")," method gets invoked for the first time (from lesson 2 & 3), and we call ",Object(a.b)("inlineCode",{parentName:"p"},"dep.depend()"),"."),Object(a.b)("p",null,"If we had written our render function from scratch inside our component (like we did on lesson 4) this is where that function would get invoked."),Object(a.b)("p",null,"Our ",Object(a.b)("inlineCode",{parentName:"p"},"render")," function returns a VNode and then our _update function gets called, found here:"),Object(a.b)("p",null,"/src/core/instance/lifecycle.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    if (vm._isMounted) {  // If we've already mounted this node on the DOM\n        callHook(vm, 'beforeUpdate')\n    }\n\n    const prevVnode = vm._vnode // Store the previous VNode\n\n    vm._vnode = vnode // set current vnode to the one we just generated and \n                        // passed into the _update method\n\n    if (!prevVnode) {\n        // If no previous VNode then DOM node created and inserted\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false, vm.$options._parentElm, vm.$options._refElm)\n    } else {\n        // Updates happen here.  Notice we're sending in the prevVnode and the new \n        // one, so that the least amount of DOM updates occur.\n        vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n}\n")),Object(a.b)("p",null,"As you can see with the comments I left above, ",Object(a.b)("inlineCode",{parentName:"p"},"_update")," eventually calls the ",Object(a.b)("inlineCode",{parentName:"p"},"__patch__")," function, sending in the information it needs to change the actual DOM. The ",Object(a.b)("inlineCode",{parentName:"p"},"__patch__")," function itself gets set based on what environment we\u2019re in. Since we\u2019re on the web, the following code get\u2019s called:"),Object(a.b)("p",null,"/src/platforms/web/runtime/index.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"Vue.prototype.__patch__ = inBrowser ? patch : noop\n")),Object(a.b)("p",null,"We are ",Object(a.b)("inlineCode",{parentName:"p"},"inBrowser")," so this leads us to the path function:"),Object(a.b)("p",null,"/src/platforms/web/runtime/patch.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import * as nodeOps from 'web/runtime/node-ops'\n...\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\n")),Object(a.b)("p",null,"And ",Object(a.b)("inlineCode",{parentName:"p"},"createPatchFunction")," leads us to the Virtual DOM or vdom library:"),Object(a.b)("p",null,"/src/core/vdom/patch.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"export function createPatchFunction (backend) { ... }\n")),Object(a.b)("p",null,"We\u2019re not actually going to look inside the ",Object(a.b)("inlineCode",{parentName:"p"},"createPatchFunction"),", as that would be diving into the internals of how the Virtual DOM does it\u2019s thing (we\u2019d need another lesson for that). However, what\u2019s interesting here is ",Object(a.b)("inlineCode",{parentName:"p"},"nodeOps")," which gets passed into it. ",Object(a.b)("inlineCode",{parentName:"p"},"nodeOps")," basically contains all of the functions needed to interact with the DOM, like these two:"),Object(a.b)("p",null,"/src/platforms/web/runtime/node-ops.js"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"export function createElement(tagName: string, vnode: VNode): Element {\n  const elm = document.createElement(tagName);\n}\n\nexport function createTextNode(text: string): Text {\n  return document.createTextNode(text);\n}\n... // A bunch more\n")),Object(a.b)("p",null,"What\u2019s interesting about the separation of the Virtual DOM and the operations needed to manipulate the actual DOM, is that you can begin to understand how you might add another entire platform\u2026 Like maybe Android? Pay attention to the folder paths:"),Object(a.b)("img",{alt:"mounting3",src:Object(i.a)("/img/mounting3.jpg")}),Object(a.b)("p",null,"I\u2019ve been told that Vue isn\u2019t quite this modular yet, and there are parts of core that still reference inBrowser. However, as Vue evolves I it will make it easier for this to be possible."),Object(a.b)("p",null,"I hope this gives you a greater understanding of the Vue internals. If you haven\u2019t yet, I highly encourage you to download the core source and take a read."))}p.isMDXComponent=!0},156:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return m}));var o=t(0),r=t.n(o);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=r.a.createContext({}),u=function(e){var n=r.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l({},n,{},e)),t},p=function(e){var n=u(e.components);return r.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=u(t),b=o,m=p["".concat(i,".").concat(b)]||p[b]||d[b]||a;return t?r.a.createElement(m,l({ref:n},s,{components:t})):r.a.createElement(m,l({ref:n},s))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=b;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=t[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},157:function(e,n,t){"use strict";var o=t(0),r=t(35);n.a=function(){return Object(o.useContext)(r.a)}},158:function(e,n,t){"use strict";t.d(n,"a",(function(){return r}));var o=t(157);function r(e){const{siteConfig:n}=Object(o.a)(),{baseUrl:t="/"}=n||{};if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?t+e.slice(1):t+e}}}]);