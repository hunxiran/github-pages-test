(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{125:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return p}));var r=n(1),a=n(6),o=(n(0),n(156)),c={id:"lesson2",title:"Proxy and Reflect",sidebar_label:"Proxy and Reflect"},l={id:"reactivity/lesson2",title:"Proxy and Reflect",description:"In our last lesson we learned how Vue 3 keeps track of `effects` to re-run them when needed. However, we\u2019re still having to manually call `track` and `trigger`. In this lesson we\u2019ll learn how to use `Reflect` and `Proxy` to call them automatically.\r",source:"@site/docs\\reactivity\\lesson2.md",permalink:"/github-pages-test/docs/reactivity/lesson2",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reactivity/lesson2.md",sidebar_label:"Proxy and Reflect",sidebar:"someSidebar",previous:{title:"Vue 3 Reactivity",permalink:"/github-pages-test/docs/reactivity/lesson1"},next:{title:"ActiveEffect Versus Ref",permalink:"/github-pages-test/docs/reactivity/lesson3"}},i=[{value:"Solution: Hooking onto Get and Set",id:"solution-hooking-onto-get-and-set",children:[]},{value:"Understanding ES6 Reflect",id:"understanding-es6-reflect",children:[]},{value:"Understanding ES6 Proxy",id:"understanding-es6-proxy",children:[]},{value:"Combining Proxy + Effect Storage",id:"combining-proxy--effect-storage",children:[]}],s={rightToc:i};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"In our last lesson we learned how Vue 3 keeps track of ",Object(o.b)("inlineCode",{parentName:"p"},"effects")," to re-run them when needed. However, we\u2019re still having to manually call ",Object(o.b)("inlineCode",{parentName:"p"},"track")," and ",Object(o.b)("inlineCode",{parentName:"p"},"trigger"),". In this lesson we\u2019ll learn how to use ",Object(o.b)("inlineCode",{parentName:"p"},"Reflect")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Proxy")," to call them automatically."),Object(o.b)("h2",{id:"solution-hooking-onto-get-and-set"},"Solution: Hooking onto Get and Set"),Object(o.b)("p",null,"We need a way to hook (or listen for) the get and set methods on our reactive objects."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"GET property => We need to ",Object(o.b)("inlineCode",{parentName:"strong"},"track")," the current effect")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"SET property => We need to ",Object(o.b)("inlineCode",{parentName:"strong"},"trigger")," any tracked dependencies (effects) for this property")),Object(o.b)("p",null,"The first step to understanding how to do this, is to understand how in Vue 3 with ES6 ",Object(o.b)("inlineCode",{parentName:"p"},"Reflect")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Proxy")," we can intercept GET and SET calls. Previously in Vue 2 we did this with ES5 ",Object(o.b)("inlineCode",{parentName:"p"},"Object.defineProperty"),"."),Object(o.b)("h2",{id:"understanding-es6-reflect"},"Understanding ES6 Reflect"),Object(o.b)("p",null,"To print out an object property I can do this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let product = { price: 5, quantity: 2 }\nconsole.log('quantity is ' + product.quantity)\n// or \nconsole.log('quantity is ' + product['quantity'])\n")),Object(o.b)("p",null,"However, I can also GET values on an object by using ",Object(o.b)("inlineCode",{parentName:"p"},"Reflect. Reflect")," allows you to get a property on an object. It\u2019s just another way to do what I wrote above:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"console.log('quantity is ' + Reflect.get(product, 'quantity'))\n")),Object(o.b)("p",null,"Why use ",Object(o.b)("inlineCode",{parentName:"p"},"reflect"),"? Good question! Because it has a feature we\u2019ll need later, hold that thought"),Object(o.b)("h2",{id:"understanding-es6-proxy"},"Understanding ES6 Proxy"),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"Proxy")," is a placeholder for another object, which by default delegates to the object. So if I run the following code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let product = { price: 5, quantity: 2 }\nlet proxiedProduct = new Proxy(product, {})\nconsole.log(proxiedProduct.quantity)\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"proxiedProduct")," delegates to the ",Object(o.b)("inlineCode",{parentName:"p"},"product")," which returns 2 as the quantity. Notice the second argument on ",Object(o.b)("inlineCode",{parentName:"p"},"Proxy")," with ",Object(o.b)("inlineCode",{parentName:"p"},"{}"),"? This is called a ",Object(o.b)("inlineCode",{parentName:"p"},"handler")," and can be used to define custom behavior on the proxy object, like intercepting ",Object(o.b)("inlineCode",{parentName:"p"},"get")," and ",Object(o.b)("inlineCode",{parentName:"p"},"set")," calls. These interceptor methods are called ",Object(o.b)("inlineCode",{parentName:"p"},"traps")," and here\u2019s how we would set a ",Object(o.b)("inlineCode",{parentName:"p"},"get")," trap on our ",Object(o.b)("inlineCode",{parentName:"p"},"handler"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let product = { price: 5, quantity: 2 }\n\nlet proxiedProduct = new Proxy(product, {\n  get() {\n    console.log('Get was called')\n    return 'Not the value'\n  }\n})\n\nconsole.log(proxiedProduct.quantity)\n")),Object(o.b)("p",null,"In the console I\u2019d see:"),Object(o.b)("p",null,"Get was called"),Object(o.b)("p",null,"Not the value"),Object(o.b)("p",null,"We\u2019ve re-written what get returns when the property value is accessed. We should probably return the actual value, which we can do like:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let product = { price: 5, quantity: 2 }\n\nlet proxiedProduct = new Proxy(product, {\n  get(target, key) {  // <--- The target (our object) and key (the property name)\n    console.log('Get was called with key = ' + key)\n    return target[key]\n  }\n})\n\nconsole.log(proxiedProduct.quantity)\n")),Object(o.b)("p",null,"Notice that the get function has two parameters, both the target which is our object (product) and the key we are trying to get, which in this case is quantity. Now we see:"),Object(o.b)("p",null,"Get was called with key = quantity"),Object(o.b)("p",null,"2"),Object(o.b)("p",null,"This is also where we can use Reflect and add an additional argument to it."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let product = { price: 5, quantity: 2 }\nlet proxiedProduct = new Proxy(product, {\n  get(target, key, receiver) {  // <--- notice the receiver\n    console.log('Get was called with key = ' + key)\n    return Reflect.get(target, key, receiver) // <----\n  }\n})\n")),Object(o.b)("p",null,"Notice our get has an additional parameter called ",Object(o.b)("inlineCode",{parentName:"p"},"receiver")," which we\u2019re sending as an argument into ",Object(o.b)("inlineCode",{parentName:"p"},"Reflect.get"),". This ensures that the proper value of ",Object(o.b)("inlineCode",{parentName:"p"},"this")," is used when our object has inherited values / functions from another object. This is why we always use ",Object(o.b)("inlineCode",{parentName:"p"},"Reflect")," inside of a ",Object(o.b)("inlineCode",{parentName:"p"},"Proxy"),", so we can keep the original behavior we are customizing."),Object(o.b)("p",null,"Now let\u2019s add a setter method, there shouldn\u2019t be any big surprises here:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let product = { price: 5, quantity: 2 }\n\nlet proxiedProduct = new Proxy(product, {\n  get(target, key, receiver) {  \n    console.log('Get was called with key = ' + key)\n    return Reflect.get(target, key, receiver) \n  }\n  set(target, key, value, receiver) {\n    console.log('Set was called with key = ' + key + ' and value = ' + value)\n    return Reflect.set(target, key, value, receiver)\n  }\n})\n\nproxiedProduct.quantity = 4\nconsole.log(proxiedProduct.quantity)\n")),Object(o.b)("p",null,"Notice that ",Object(o.b)("inlineCode",{parentName:"p"},"set")," looks very similar to get except that it\u2019s using ",Object(o.b)("inlineCode",{parentName:"p"},"Reflect.set")," which receives the ",Object(o.b)("inlineCode",{parentName:"p"},"value")," to set the ",Object(o.b)("inlineCode",{parentName:"p"},"target")," (product). Our output as expected is:"),Object(o.b)("p",null,"Set was called with key = quantity and value = 4"),Object(o.b)("p",null,"Get was called with key = quantity"),Object(o.b)("p",null,"4"),Object(o.b)("p",null,"There\u2019s another way we can encapsulate this code, which is what you see in the Vue 3 source code. First, we\u2019ll wrap this proxying code in a ",Object(o.b)("inlineCode",{parentName:"p"},"reactive")," function which returns the proxy, which should look familiar if you\u2019ve played with the Vue 3 Composition API. Then we\u2019ll declare our ",Object(o.b)("inlineCode",{parentName:"p"},"handler")," with it\u2019s ",Object(o.b)("inlineCode",{parentName:"p"},"traps")," separately and send them into our proxy."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"function reactive(target) {\n  const handler = {\n    get(target, key, receiver) {\n      console.log('Get was called with key = ' + key)\n      return Reflect.get(target, key, receiver)\n    },\n    set(target, key, value, receiver) {\n      console.log('Set was called with key = ' + key + ' and value = ' + value)\n      return Reflect.set(target, key, value, receiver)\n    }\n  }\n  return new Proxy(target, handler)\n}\n\nlet product = reactive({ price: 5, quantity: 2 }) // <-- Returns a proxy object\nproduct.quantity = 4\nconsole.log(product.quantity)\n")),Object(o.b)("p",null,"This would return the same as above, but now we can easily create multiple reactive objects."),Object(o.b)("h2",{id:"combining-proxy--effect-storage"},"Combining Proxy + Effect Storage"),Object(o.b)("p",null,"If we take the code we have for creating reactive objects, and remember:"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"GET property => We need to ",Object(o.b)("inlineCode",{parentName:"strong"},"track")," the current effect")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"SET property => We need to ",Object(o.b)("inlineCode",{parentName:"strong"},"trigger")," any tracked dependencies (",Object(o.b)("inlineCode",{parentName:"strong"},"effects"),") for this property")),Object(o.b)("p",null,"We can start to imagine where we need to call track and trigger with the code above:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"function reactive(target) {\n  const handler = {\n    get(target, key, receiver) {\n      let result = Reflect.get(target, key, receiver)\n        // Track\n      return result\n    },\n    set(target, key, value, receiver) {\n      let oldValue = target[key]\n      let result = Reflect.set(target, key, value, receiver)\n      if (oldValue != result) { // Only if the value changes \n        // Trigger\n      } \n      return result\n    }\n  }\n  return new Proxy(target, handler)\n}\n")),Object(o.b)("p",null,"Now let\u2019s put the two pieces of code together:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const targetMap = new WeakMap() // targetMap stores the effects that each object should re-run when it's updated\nfunction track(target, key) {\n  // We need to make sure this effect is being tracked.\n  let depsMap = targetMap.get(target) // Get the current depsMap for this target\n  if (!depsMap) {\n    // There is no map.\n    targetMap.set(target, (depsMap = new Map())) // Create one\n  }\n  let dep = depsMap.get(key) // Get the current dependencies (effects) that need to be run when this is set\n  if (!dep) {\n    // There is no dependencies (effects)\n    depsMap.set(key, (dep = new Set())) // Create a new Set\n  }\n  dep.add(effect) // Add effect to dependency map\n}\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target) // Does this object have any properties that have dependencies (effects)\n  if (!depsMap) {\n    return\n  }\n  let dep = depsMap.get(key) // If there are dependencies (effects) associated with this\n  if (dep) {\n    dep.forEach(effect => {\n      // run them all\n      effect()\n    })\n  }\n}\n\nfunction reactive(target) {\n  const handler = {\n    get(target, key, receiver) {\n      let result = Reflect.get(target, key, receiver)\n      track(target, key) // If this reactive property (target) is GET inside then track the effect to rerun on SET\n      return result\n    },\n    set(target, key, value, receiver) {\n      let oldValue = target[key]\n      let result = Reflect.set(target, key, value, receiver)\n      if (oldValue != result) {\n        trigger(target, key) // If this reactive property (target) has effects to rerun on SET, trigger them.\n      }\n      return result\n    }\n  }\n  return new Proxy(target, handler)\n}\n\nlet product = reactive({ price: 5, quantity: 2 })\nlet total = 0\n\nlet effect = () => {\n  total = product.price * product.quantity\n}\neffect()\n\nconsole.log('before updated quantity total = ' + total)\nproduct.quantity = 3\nconsole.log('after updated quantity total = ' + total)\n")),Object(o.b)("p",null,"Notice how we no longer need to call ",Object(o.b)("inlineCode",{parentName:"p"},"trigger")," and ",Object(o.b)("inlineCode",{parentName:"p"},"track")," because these are getting properly called inside our ",Object(o.b)("inlineCode",{parentName:"p"},"get")," and ",Object(o.b)("inlineCode",{parentName:"p"},"set")," methods. Running this code gives us:"),Object(o.b)("p",null,"before updated quantity total = 10"),Object(o.b)("p",null,"after updated quantity total = 15"),Object(o.b)("p",null,"Wow, we\u2019ve come a long way! There\u2019s only one bug to fix before this code is solid. Specifically, that we only want ",Object(o.b)("inlineCode",{parentName:"p"},"track")," to be called on a reactive object if it\u2019s inside an ",Object(o.b)("inlineCode",{parentName:"p"},"effect"),". Right now track will be called whenever a reactive object property is ",Object(o.b)("inlineCode",{parentName:"p"},"get"),". We\u2019ll polish this up in the next lesson."))}p.isMDXComponent=!0},156:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),p=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},u=function(e){var t=p(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=p(n),b=r,h=u["".concat(c,".").concat(b)]||u[b]||d[b]||o;return n?a.a.createElement(h,l({ref:t},s,{components:n})):a.a.createElement(h,l({ref:t},s))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=b;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,c[1]=l;for(var s=2;s<o;s++)c[s]=n[s];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);