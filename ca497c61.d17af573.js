(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{140:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return u}));var a=n(1),r=n(6),c=(n(0),n(156)),l={id:"lesson3",title:"ActiveEffect Versus Ref",sidebar_label:"ActiveEffect and Ref"},o={id:"reactivity/lesson3",title:"ActiveEffect Versus Ref",description:"In this lesson we\u2019ll continue to build out our reactivity code by fixing a small bug and then implementing reactive references, much like you might have seen in Vue 3. The bottom of our current code from the last lesson looks like this:\r",source:"@site/docs\\reactivity\\lesson3.md",permalink:"/github-pages-test/docs/reactivity/lesson3",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reactivity/lesson3.md",sidebar_label:"ActiveEffect and Ref",sidebar:"someSidebar",previous:{title:"Proxy and Reflect",permalink:"/github-pages-test/docs/reactivity/lesson2"},next:{title:"Reading Vue 3 Source",permalink:"/github-pages-test/docs/reactivity/lesson4"}},i=[{value:"Solution: activeEffect",id:"solution-activeeffect",children:[]},{value:"The Need for Ref",id:"the-need-for-ref",children:[]},{value:"1. Defining Ref with Reactive",id:"1-defining-ref-with-reactive",children:[]},{value:"Understanding JavaScript Object Accessors",id:"understanding-javascript-object-accessors",children:[]},{value:"2. Defining Ref with Object Accessors",id:"2-defining-ref-with-object-accessors",children:[]},{value:"Coming Up",id:"coming-up",children:[]}],s={rightToc:i};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(c.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(c.b)("p",null,"In this lesson we\u2019ll continue to build out our reactivity code by fixing a small bug and then implementing reactive references, much like you might have seen in Vue 3. The bottom of our current code from the last lesson looks like this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"...\nlet product = reactive({ price: 5, quantity: 2 })\nlet total = 0\n\nlet effect = () => {\n  total = product.price * product.quantity\n}\neffect()\n\nconsole.log(total)\n\nproduct.quantity = 3\n\nconsole.log(total)\n")),Object(c.b)("p",null,"The problem arrives when we add code which GETs a property from our reactive object, like so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"console.log('Updated quantity to = ' + product.quantity)\n")),Object(c.b)("p",null,"The issue here is that ",Object(c.b)("inlineCode",{parentName:"p"},"track")," and all of it\u2019s function will get called, even if we\u2019re not inside an ",Object(c.b)("inlineCode",{parentName:"p"},"effect"),". We only want to look up and record the effect if ",Object(c.b)("inlineCode",{parentName:"p"},"get")," is called inside the active effect."),Object(c.b)("h2",{id:"solution-activeeffect"},"Solution: activeEffect"),Object(c.b)("p",null,"To solve this problem, we\u2019ll first create an ",Object(c.b)("inlineCode",{parentName:"p"},"activeEffect"),", a global variable we\u2019ll store the currently running effect in. We\u2019ll then set this inside a new function called ",Object(c.b)("inlineCode",{parentName:"p"},"effect"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"let activeEffect = null // The active effect running\n...\nfunction effect(eff) {\n  activeEffect = eff  // Set this as the activeEffect\n  activeEffect()      // Run it\n  activeEffect = null // Unset it\n}\n\nlet product = reactive({ price: 5, quantity: 2 })\nlet total = 0\n\neffect(() => {\n  total = product.price * product.quantity\n})\n\neffect(() => {\n  salePrice = product.price * 0.9\n})\n\nconsole.log(\n  `Before updated total (should be 10) = ${total} salePrice (should be 4.5) = ${salePrice}`\n)\n\nproduct.quantity = 3\n\nconsole.log(\n  `After updated total (should be 15) = ${total} salePrice (should be 4.5) = ${salePrice}`\n)\n\nproduct.price = 10\n\nconsole.log(\n  `After updated total (should be 30) = ${total} salePrice (should be 9) = ${salePrice}`\n)\n")),Object(c.b)("p",null,"Notice that we no longer need to call the ",Object(c.b)("inlineCode",{parentName:"p"},"effect")," manually. It\u2019s getting called automatically inside our new ",Object(c.b)("inlineCode",{parentName:"p"},"effect")," function. Notice I\u2019ve also added a second ",Object(c.b)("inlineCode",{parentName:"p"},"effect"),", because why not \ud83d\ude01. I\u2019ve also updated our ",Object(c.b)("inlineCode",{parentName:"p"},"console.logs")," to look more like tests, so we can verify the proper output. You can try out all the code yourself by grabbing it ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Code-Pop/vue-3-reactivity"}),"off github"),"."),Object(c.b)("p",null,"So good so far, but there\u2019s one more change we need to make, and that\u2019s inside the ",Object(c.b)("inlineCode",{parentName:"p"},"track")," function. It needs to use our new ",Object(c.b)("inlineCode",{parentName:"p"},"activeEffect"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"function track(target, key) {\n  if (activeEffect) { // <------ Check to see if we have an activeEffect\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map())) \n    }\n    let dep = depsMap.get(key) \n    if (!dep) {\n      depsMap.set(key, (dep = new Set())) // Create a new Set\n    }\n    dep.add(activeEffect) // <----- Add activeEffect to dependency map\n  }\n}\n")),Object(c.b)("p",null,"Great, now if we run our code we properly get:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"Before updated total (should be 10) = 10 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 15) = 15 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 30) = 30 salePrice (should be 9) = 9\n")),Object(c.b)("p",null,"If you want to walk through this code executing line by line, definitely check out the video."),Object(c.b)("h2",{id:"the-need-for-ref"},"The Need for Ref"),Object(c.b)("p",null,"When I was coding up this challenge I realized that the way I was calculating total might make a little more sense if it used the salePrice rather than price, like so:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"effect(() => {\n  total = salePrice * product.quantity\n})\n")),Object(c.b)("p",null,"If we were creating a real store, we\u2019d probably calculate the total based on the salePrice. However, this code wouldn\u2019t work reactively. Specifically, when product.price is updated, it will reactively recalculate the salePrice with this effect:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"effect(() => {\n  salePrice = product.price * 0.9\n})\n")),Object(c.b)("p",null,"But since salePrice isn\u2019t reactive, the effect with total won\u2019t get recalculated. Our first effect above won\u2019t get re-run. We need some way to make salePrice reactive, and it\u2019d be nice if we didn\u2019t have to wrap it in another reactive object. If you\u2019re familiar with the Composition API, which I teach in the Vue 3 Essentials Course, you might be thinking that I should use ref to create a Reactive Reference. Let\u2019s do this:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"let product = reactive({ price: 5, quantity: 2 })\nlet salePrice = ref(0)\nlet total = 0\n")),Object(c.b)("p",null,"According to the Vue documentation, a reactive reference takes an inner value and returns a reactive and mutable ref object. The ref object has a single property .value that points to the inner value. So we\u2019d need to change around our effects a little to use .value."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"effect(() => {\n  total = salePrice.value * product.quantity\n})\n\neffect(() => {\n  salePrice.value = product.price * 0.9\n})\n")),Object(c.b)("p",null,"Our code should work now, properly updating the total when salePrice is updated. However, we still need to define ref. There\u2019s two ways we could do it."),Object(c.b)("h2",{id:"1-defining-ref-with-reactive"},"1. Defining Ref with Reactive"),Object(c.b)("p",null,"First, we could simply use reactive as we\u2019ve defined it:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"function ref(intialValue) {\n  return reactive({ value: initialValue })\n}\n")),Object(c.b)("p",null,"However, this isn\u2019t how Vue 3 defines ref with primitives, so let\u2019s implement it differently."),Object(c.b)("h2",{id:"understanding-javascript-object-accessors"},"Understanding JavaScript Object Accessors"),Object(c.b)("p",null,"In order to understand how Vue 3 defines ref, we first need to make sure we are familiar with object accessors. These are sometimes also known as JavaScript computed properties (not to be confused with Vue computed properties). Below you can see a simple example which uses Object Accessors:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"let user = {\n  firstName: 'Gregg',\n  lastName: 'Pollack',\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`\n  },\n\n  set fullName(value) {\n    [this.firstName, this.lastName] = value.split(' ')\n  },\n}\n\nconsole.log(`Name is ${user.fullName}`)\nuser.fullName = 'Adam Jahr'\nconsole.log(`Name is ${user.fullName}`)\n")),Object(c.b)("p",null,"The get and set lines are object accessors to get fullName and set fullName accordingly. This is plain JavaScript, and is not a feature of Vue."),Object(c.b)("h2",{id:"2-defining-ref-with-object-accessors"},"2. Defining Ref with Object Accessors"),Object(c.b)("p",null,"Using Object Accessors, along with our track and trigger actions, we can now define ref using:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"function ref(raw) {\n  const r = {\n    get value() {\n      track(r, 'value')\n      return raw\n    },\n    set value(newVal) {\n      raw = newVal\n      trigger(r, 'value')\n    },\n  }\n  return r\n}\n")),Object(c.b)("p",null,"That\u2019s all there is to it. Now when we run the following code:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"...\nfunction ref(raw) {\n  const r = {\n    get value() {\n      track(r, 'value')\n      return raw\n    },\n    set value(newVal) {\n      raw = newVal\n      trigger(r, 'value')\n    },\n  }\n  return r\n}\n\nfunction effect(eff) {\n  activeEffect = eff\n  activeEffect()\n  activeEffect = null\n}\n\nlet product = reactive({ price: 5, quantity: 2 })\nlet salePrice = ref(0)\nlet total = 0\n\neffect(() => {\n  total = salePrice.value * product.quantity\n})\n\neffect(() => {\n  salePrice.value = product.price * 0.9\n})\n\nconsole.log(\n  `Before updated quantity total (should be 9) = ${total} salePrice (should be 4.5) = ${salePrice.value}`\n)\nproduct.quantity = 3\nconsole.log(\n  `After updated quantity total (should be 13.5) = ${total} salePrice (should be 4.5) = ${salePrice.value}`\n)\nproduct.price = 10\nconsole.log(\n  `After updated price total (should be 27) = ${total} salePrice (should be 9) = ${salePrice.value}`\n)\n")),Object(c.b)("p",null,"We get what we would expect:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"Before updated total (should be 10) = 10 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 13.5) = 13.5 salePrice (should be 4.5) = 4.5\nAfter updated total (should be 27) = 27 salePrice (should be 9) = 9\n")),Object(c.b)("p",null,"Our salePrice is now reactive and total gets updated when it changes!"),Object(c.b)("h2",{id:"coming-up"},"Coming Up"),Object(c.b)("p",null,"In our next lesson we\u2019ll take our code a little deeper and look at how we might create a computed property like Vue 3 does."))}u.isMDXComponent=!0},156:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){c(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),u=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o({},t,{},e)),n},d=function(e){var t=u(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},f=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,c=e.originalType,l=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),d=u(n),f=a,b=d["".concat(l,".").concat(f)]||d[f]||p[f]||c;return n?r.a.createElement(b,o({ref:t},s,{components:n})):r.a.createElement(b,o({ref:t},s))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var c=n.length,l=new Array(c);l[0]=f;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<c;s++)l[s]=n[s];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"}}]);